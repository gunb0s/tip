컨테이너화된 애플리케이션의 stdout, stderr 스트림에 의해 생성된 모든 출력은 컨테이너 런타임이 처리하고 리디렉션 시킨다.

다양한 컨테이너 런타임들은 이를 각자 다른 방법으로 구현하였지만, **`*kubelet`** 과의 호환성은 **`CRI`** 로깅 포맷*으로 표준화 되어 있다.

기본적으로 컨테이너가 재시작하는 경우,

**`kubelet`**은 종료된 컨테이너 하나를 로그와 함께 유지한다.

파드가 노드에서 축출되면, 해당하는 모든 컨테이너와 로그가 함께 축출된다.

## Log Rotation

`kubelet`이 로그를 자동으로 로테이트하도록 설정.

로테이션을 구성해놓으면, `kubelet`은 컨테이너 로그를 로테이트하고 로깅 경로 구조를 관리한다. `kubelet`은 이 정보를 컨테이너 런타임에 전송하고 (`CRI`를 사용), 런타임은 지정된 위치에 컨테이너 로그를 기록한다.

<aside> 💡 로그 로테이션 — 일정한 크기나, 시간 간격으로 나누어 로그 파일을 관리하여 로그 파일이 비대해지는 것을 방지한다.

</aside>

`kubelet` 설정 파일 (`--config-dir=/etc/kubernetes/kubelet.conf.d`)을 사용하여 `containerLogMaxSize`, `containerLogMaxFiles` 파라미터 값 설정이 가능하다.

<aside> 💡 `kubectl logs` 를 통해서는 최신 로그만 확인할 수 있다. 예를 들어 파드가 `40MiB` 크기의 로그를 기록했고 `kubelet`이 `10Mib`마다 로그를 로테이트하는 경우 `kubectl logs`는 최근의 `10MiB` 데이터만 반환한다.

</aside>

## System Component Log

시스템 컴포넌트에는 컨테이너에서 실행되는 것과 실행 중인 컨테이너와 직접적인 연관이 있는 것 두 가지 유형이 있다.

- `kubelet` 과 컨테이너 런타임은 컨테이너에서 실행되지 않는다. `kubelet`이 컨테이너를 실행시킨다.
- 쿠버네티스의 스케쥴러, 컨트롤러 매니저, API 서버는 파드(일반적으로 스태틱파드)로 실행된다. `etcd`는 컨트롤 플레인에서 실행되며, 대부분의 경우 역시 스태틱 파드로써 실행된다. 클러스터가 kube-proxy를 사용하는 경우는 데몬셋으로서 실행된다.

### 로그의 위치

- Linux
	`systemd`를 사용하는 시스템에서는 `kubelet`과 컨테이너 런타임은 기본적으로 로그를 `journald`에 작성한다. `journalctl`을 사용하여 이를 확인할 수 있다 (`journalctl -u kubelet`)
    
    `systemd`를 사용하지 않는 시스템에서, `kubelet`과 컨테이너 런타임은 로그를 `/var/log` 디렉터리의 `.log` 파일에 작성한다. 다른 경로에 로그를 기록하고 싶은 경우에는, `kube-log-runner` 를 통해 간접적으로 `kubelet`을 실행하여 `kubelet`의 로그를 지정한 디렉토리로 리디렉션할 수 있다.
    
    `kubelet`을 실행할 때 `—log-dir` 인자를 통해 로그가 저장될 디렉토리를 지정할 수 있다. 그러나 해당 인자는 더이상 지원되지 않으며, `kubelet`은 항상 컨테이너 런타임으로 하여금 `/var/log/pods` 아래에 로그를 기록하도록 지시한다.

> [!info]
`systemd`는 `Linux` 시스템에서 시스템 및 서비스 관리를 위한 Init 시스템 `journald`는 `systemd`의 로그 수집 및 관리 데몬, 시스템 로그, 커널 로그, 사용자 로그 등을 수집하여 중앙 집중식(`/var/log/journal`)으로 저장한다. 
`journalctl`은 `journald` 로그를 조회하고 관리하는데 사용되는 명령어 -u 특정 서비스의 조회 → `journalctl -u kubelet`
실행되고 있는 서비스 조회 `systemctl list-units --type=service --state=running`

> [!question] Difference Between ps and systemctl list
> `systemctl`은 `systemd` 시스템 및 서비스 관리자와 상호작용하는데에 사용. 주로 서비스의 상태를 확인하고 시작, 중지, 재시작하는 등의 작업 수행
> `ps`는 현재 실행중인 프로세스를 나열하는데 사용, 주로 프로세스 모니터링과 관련된 작업에 사용


파드로 실행되는 쿠버네티스 컴포넌트의 경우, 기본 로깅 메커니즘을 따르지 않고 /var/log 아래에 기록한다 (즉, 해당 컴포넌트들은 `systemd`의 `journal`에 로그를 기록하지 않는다) 
**쿠버네티스의 저장 매커니즘을 사용하여, 컴포넌트를 실행하는 컨테이너에 영구적으로 사용 가능한 저장 공간을 연결할 수 있다.**

> [!NOTE]
> 스케줄러와 같은 쿠버네티스 클러스터의 컴포넌트를 배포하여 상위 노드에서 공유된 볼륨에 로그를 기록하는 경우, 해당 로그들이 로테이트되는지 확인하고 관리해야 한다. 쿠버네티스가 해당 볼륨의 로그 로테이션을 관리하지는 않는다.

## 클러스터 레벨 로깅 아키텍쳐

사용가능한 몇 가지 옵션
- 모든 노드에서 실행되는 노드-레벨 로깅 에이전트를 사용한다.
- 애플리케이션 파드에 로깅을 위한 전용 사이드카 컨테이너를 포함한다.
- 애플리케이션 내에서 로그를 백엔드로 직접 푸시한다.
### 노드 로깅 에이전트 사용
![[Pasted image 20240801150509.png]]

### 로깅 에이전트와 함께 사이드카 컨테이너 사용
![[Pasted image 20240801151156.png]]
- 사이드카 컨테이너는 애플리케이션 로그 자체를 `stdout`으로 스트리밍한다.
- 사이드카 컨테이너는 로깅 에이전트를 실행하며, 어플리케이션 컨테이너에서 로그를 가져오도록 구성된다.

### 애플리케이션에서 직접 로그 노출
![[Pasted image 20240801151633.png]]